!=========================================================================
!This program reads in polarizability of two layer system from chimat1 
!and chimat2 generated by BGW epsilon. 
!Calculate the total polarizability and write into file chimat
!                  
!=========================================================================

program chisimpleadd

  implicit none

  integer, parameter :: DP = kind(1.0d0)
  integer, parameter :: DPC = kind((1.0d0,1.0d0))
  real(DP), parameter :: BOHR = 0.52917721092_dp
  real(DP), parameter :: RYD = 13.60569253_dp
  real(DP), parameter :: PI_D = 3.1415926535897932384626433832795_dp
  real(DP), parameter :: E_D = 2.7182818284590452353602874713526_dp
  real(DP), parameter :: TOL_ZERO = 1.0d-12
  real(DP), parameter :: TOL_Small = 1.0d-6
!-------------------
  type symmetry
    integer :: ntran         !< number of operations in full group
    integer :: ntranq        !< number of operations in small group of q
    real(DP) :: rq(3)        !< The q-point this ntranq belongs to
    integer :: mtrx(3,3,48)  !< symmetry matrix
    real(DP) :: tnp(3,48)    !< fractional translations
    integer :: indsub(48)    !< symmetry operations in subgroup of q
    integer :: kgzero(3,48)  !< Umklapp vectors for subgroup symmetry operations
    integer :: cell_symmetry !< 0 = cubic, 1 = hexagonal
  end type symmetry
!------------------
  type gspace
    integer :: ng       !< number of G-vectors
    integer :: nFFTgridpts !< number in FFT grid = product(FFTgrid(1:3))
    real(DP) :: ecutrho !< charge-density cutoff, in Ry
    integer, pointer :: components(:,:) !< the G-vectors, in units of 2 pi / a
    integer :: FFTgrid(3)  !< gsm: FFTgrid is the size of the FFT grid, not the maximum G-vector   
    integer, pointer :: index_vec(:) ! mapping to FFT grid
    real(DP), pointer :: ekin(:) !< kinetic energy of G-vectors
  end type gspace
!------------------
  type (symmetry) :: syms
  type (gspace) :: gvec1, gvec2
  logical :: use_q0, slab, initial_read
  character :: dummy,calcname*12
  character :: aheadinput*60, ajname*6, adate*11, atime*14
!  integer :: x, y, z, xp, yp, zp
  integer :: nq,nq1,nq2,nq0,ngq,n,k,i,j,ii,jj,nmtx1,nmtx2,ig,igp,iq,ioerr,allocerr,np
  integer :: freq_dep, nFreq, nband, nrk, icount, ndum
  integer :: kmax(3), nmax(3), nfft(6), maxnfft(6), qgrid(3)
  integer, allocatable :: isrtx1(:), isrtx2(:),irow(:)
  real(DP) :: ecuts,temp1,temp2,temp3,temp4
  real(DP) :: bdot(3,3)
  real(DP), allocatable :: qpt1(:,:), qpt2(:,:), q_fzeps(:,:)
  complex(DPC), allocatable :: chimat1_ggp(:,:),chimat2_ggp(:,:),chimat_ggp(:,:),chimat3_ggp(:,:)
!------------program start-----------------
  open(14,file='chimat_bnG',form='unformatted',status='old')
  open(15,file='chimat_add',form='unformatted',status='replace')
  open(16,file='diagplot',form='formatted',status='replace')
  open(17,file='offdiagplot',form='formatted',status='replace')

  write(*,*) " number of qpoints in chimat_bn and chimat_G 4"
  read(*,*) nq
  initial_read = .true.
  do iq = 2,nq !
!-----------------------------
! Read chimat_G    sys_2
      if (initial_read) then
        read(14)
        read(14)
        read(14)
        read(14)        
        read(14)
        read(14)
        read(14)
        read(14)
        read(14)
        read(14)
        open(12,file='chimat_G',form='unformatted',status='old',iostat=ioerr)
        read(12)
        read(12)
        read(12)
        read(12)
        read(12)
        read(12)
        read(12)
        read(12)
        read(12) gvec2%ng
       backspace(12)
       allocate ( gvec2%components(3,gvec2%ng) ) 

        read(12) gvec2%ng,gvec2%nFFTgridpts,gvec2%FFTgrid(1:3), &
              ((gvec2%components(jj,ig),jj=1,3),ig=1,gvec2%ng)
        read(12) nq2
       backspace(12)
       allocate (qpt2(3,nq2))
        read(12) nq2,nq0,((qpt2(jj,ii),jj=1,3),ii=1,nq2)
        write(*,*) 'nq2',nq2
       do ii = 1,nq2
        write(6,'(3f10.6)') qpt2(:,ii)
       enddo

!        initial_read = .false.
      endif
      ! Read q-dependent info
      read(12)
      allocate (isrtx2(gvec2%ng))
      allocate (gvec2%ekin(gvec2%ng))
!      read(12) nmtx2,np,(isrtx2(i),gvec2%ekin(i),i=1,gvec2%ng)
      read(12) nmtx2
      write(*,*) "nmtx2",iq,nmtx2
      allocate (chimat2_ggp (nmtx2,nmtx2), stat=allocerr)
       read(14)
       read(14)
      allocate (chimat3_ggp (nmtx2,nmtx2), stat=allocerr)
      do igp = 1,nmtx2
        ! read the chimat2 matrix column-by-column
        read(12) (chimat2_ggp(ig,igp),ig=1,nmtx2)
        read(14) (chimat3_ggp(ig,igp),ig=1,nmtx2)
      enddo

!-----------------------------
! Read Chimat1. Add chimat2 and write

      if (initial_read) then
        open(11,file='chimat_bn',form='unformatted',status='old',iostat=ioerr)
        read(11) aheadinput,ajname,adate
        read(11) freq_dep,nFreq
        read(11) qgrid(1:3)
        read(11)
        read(11)
        read(11)
        read(11) ecuts,nband
        read(11) nrk
        read(11) gvec1%ng,gvec1%nFFTgridpts
        write(*,*) 'check backspace:'
        write(*,*) gvec1%ng,gvec1%nFFTgridpts
       if (gvec1%ng .ne. gvec2%ng) then
        write(*,*) 'STOP: gvec1%ng .ne. gvec2%ng'
        stop
       endif

       backspace(11)
        read(11) i
        if(i .ne. gvec1%ng)then
        write(*,*) 'check backspace:'
        write(*,*) i
        stop
        endif
       backspace(11)
       allocate ( gvec1%components(3,gvec1%ng) )
       allocate ( gvec1%index_vec(gvec1%nFFTgridpts) )
        read(11) gvec1%ng,gvec1%nFFTgridpts,gvec1%FFTgrid(1:3), &
              ((gvec1%components(jj,ig),jj=1,3),ig=1,gvec1%ng), &
              ((bdot(ii,jj),jj=1,3),ii=1,3),(gvec1%index_vec(ig),ig=1,gvec1%nFFTgridpts)

      do ig = 1 , gvec1%ng
       if(all( abs(gvec1%components(1:3,ig)-gvec2%components(1:3,ig)) .lt. TOL_Small )) then
!        write(*,*) 'STOP: gvec1 .ne. gvec2'      
       else
        write(*,*) 'STOP: gvec1 .ne. gvec2'
        stop
       endif
      enddo
        read(11) nq1
       backspace(11)
       allocate (qpt1(3,nq1))
        read(11) nq1,nq0,((qpt1(jj,ii),jj=1,3),ii=1,nq1)
        write(*,*) 'nq1',nq1
      do ii = 1,nq1
        write(6,'(3f10.6)') qpt1(:,ii)
      enddo

        initial_read = .false.
        write(15) aheadinput,ajname,adate
        write(15) freq_dep,nFreq
        write(15) qgrid(1:3)
        write(15)
        write(15)
        write(15)
        write(15) ecuts,nband
        write(15) nrk, 1
        write(15) gvec1%ng,gvec1%nFFTgridpts,gvec1%FFTgrid(1:3),&
              ((gvec1%components(jj,ig),jj=1,3),ig=1,gvec1%ng), &
              ((bdot(ii,jj),jj=1,3),ii=1,3),(gvec1%index_vec(ig),ig=1,gvec1%nFFTgridpts)
        write(15) nq1,nq0,((qpt1(jj,ii),jj=1,3),ii=1,nq1)
      endif ! initial_read
      ! Read q-dependent info
      read(11) syms%ntranq
      backspace(11)
      read(11) syms%ntranq,(((syms%mtrx(i,j,syms%indsub(n)),i=1,3),j=1,3), &
            (syms%tnp(k,syms%indsub(n)),syms%kgzero(k,n),k=1,3),n=1,syms%ntranq)
      allocate (isrtx1(gvec1%ng))
      allocate (gvec1%ekin(gvec1%ng))
      read(11) nmtx1
      allocate (irow(nmtx1))
      backspace(11)
      read(11) nmtx1,np,(isrtx1(i),gvec1%ekin(i),i=1,gvec1%ng),(irow(i),i=1,nmtx1)
!      write(15) syms%ntranq,(((syms%mtrx(i,j,syms%indsub(n)),i=1,3),j=1,3), &
!            (syms%tnp(k,syms%indsub(n)),syms%kgzero(k,n),k=1,3),n=1,syms%ntranq)
      write(15) syms%ntranq
!      write(15) nmtx1,np,(isrtx1(i),gvec1%ekin(i),i=1,gvec1%ng),(irow(i),i=1,nmtx1)
      write(15) nmtx1
      if (nmtx1 .ne. nmtx2) then 
        write(*,*) 'STOP: nmtx1 .ne. nmtx2'
        stop
      endif

      write(*,*) "nmtx1",iq,nmtx1
      allocate (chimat1_ggp (nmtx1,nmtx1), stat=allocerr)
      allocate (chimat_ggp (nmtx1,nmtx1), stat=allocerr)

      do igp = 1,nmtx1
        ! read the chimat1 matrix column-by-column
        read(11) (chimat1_ggp(ig,igp),ig=1,nmtx1)
        do ig = 1,nmtx1
          chimat_ggp(ig,igp)=chimat1_ggp(ig,igp)+chimat2_ggp(ig,igp) 
        enddo
        ! write the chimat matrix column-by-column
        write(15) (chimat_ggp(ig,igp),ig=1,nmtx1)
      enddo
!        write(*,*) 'total chi at (1,1)',chimat_ggp(1,1)
!        write(*,*) chimat1_ggp(1,1)
!        write(*,*) chimat2_ggp(1,1)
      temp4 = 0.0
      icount = 0.0
      do igp = 1,nmtx1
       do ig = 1,nmtx1
         temp1 = REAL(chimat_ggp(ig,igp))
         temp2 = REAL(chimat3_ggp(ig,igp))
         temp3 = abs((temp1 - temp2 )/temp2)
          if (temp3 .gt. 1.01)then
!           write(*,*) ig,igp
!          write(*,*) temp1,temp2
          icount = icount +1
          endif
         if (temp3 .gt. temp4)then
          temp4 = temp3
!          if (temp4 .gt. 0.00001)then
!           write(*,*) ig,igp
!          write(*,*) temp1,temp2
!          endif
         endif
!         ig = igp
!         temp1 = REAL(chimat_ggp(ig,igp))
!         temp2 = REAL(chimat3_ggp(ig,igp))
!         temp3 = AIMAG(chimat_ggp(ig,igp))
!         temp4 = AIMAG(chimat3_ggp(ig,igp))
!        write(16,'(i4,4f14.9)') igp,temp1,temp2,temp3,temp4
!         ig = nmtx1 +1 - igp
!         temp1 = REAL(chimat_ggp(ig,igp))
!         temp2 = REAL(chimat3_ggp(ig,igp))
!         temp3 = AIMAG(chimat_ggp(ig,igp))
!         temp4 = AIMAG(chimat3_ggp(ig,igp))
!        write(17,'(i4,4f14.9)') igp,temp1,temp2,temp3,temp4
       enddo
      enddo
        write(*,*) 'icount,max error',icount,temp4,iq
    deallocate (isrtx1)
    deallocate (isrtx2)
    deallocate (irow)
    deallocate (gvec1%ekin)
    deallocate (gvec2%ekin)
    deallocate(chimat1_ggp)
    deallocate(chimat2_ggp)
    deallocate(chimat3_ggp)
    deallocate(chimat_ggp)
        write(*,*) '-------------------------------------------'
  enddo !iq
    deallocate ( gvec1%index_vec)
    deallocate(gvec1%components)
    deallocate(gvec2%components)
    deallocate (qpt1)
    deallocate (qpt2)
!  write(*,*) "chimat_M",chimat1_ggp(1,1),chimat1_ggp(nmtx,nmtx)
  close(11)
  close(12)
  close(15)
  close(14)
  close(16)
  close(17)
  write(*,*) "Done reading and writing"
!----------------------------------
  write(*,*) "Finish"

end program chisimpleadd
